package osvscanner

import (
	"testing"

	"github.com/google/osv-scanner/internal/config"
	"github.com/google/osv-scanner/internal/imodels"
	"github.com/google/osv-scanner/internal/imodels/ecosystem"
	"github.com/google/osv-scanner/internal/imodels/results"
	"github.com/google/osv-scanner/internal/testutility"
	"github.com/google/osv-scanner/pkg/models"
	"github.com/google/osv-scanner/pkg/osv"
	"github.com/google/osv-scanner/pkg/reporter"
)

func Test_assembleResult(t *testing.T) {
	t.Parallel()
	type args struct {
		r           reporter.Reporter
		actions     ScannerActions
		scanResults *results.ScanResults
		config      config.Manager
	}
	packages := []imodels.PackageInfo{
		{
			Name:       "pkg-1",
			Ecosystem:  ecosystem.MustParse("npm"),
			Version:    "1.0.0",
			Location:   "dir/package-lock.json",
			SourceType: imodels.SourceTypeProjectPackage,
		}, {
			Name:       "pkg-2",
			Ecosystem:  ecosystem.MustParse("npm"),
			Version:    "1.0.0",
			Location:   "dir/package-lock.json",
			SourceType: imodels.SourceTypeProjectPackage,
		}, {
			Name:       "pkg-3",
			Ecosystem:  ecosystem.MustParse("npm"),
			Version:    "1.0.0",
			Location:   "other-dir/package-lock.json",
			SourceType: imodels.SourceTypeProjectPackage,
		},
	}
	vulnsResp := &osv.HydratedBatchedResponse{
		Results: []osv.Response{
			{Vulns: models.Vulnerabilities([]models.Vulnerability{
				{
					ID:      "GHSA-123",
					Aliases: []string{"CVE-123"},
				}, {
					ID: "CVE-123",
				},
			})},
			{Vulns: models.Vulnerabilities{}},
			{Vulns: models.Vulnerabilities([]models.Vulnerability{
				{
					ID: "GHSA-456",
				},
			})},
		},
	}

	licensesResp := [][]models.License{
		{models.License("MIT"), models.License("0BSD")},
		{models.License("MIT")},
		{models.License("UNKNOWN")},
	}

	makeLicensesResp := func() [][]models.License {
		cpy := make([][]models.License, len(licensesResp))
		copy(cpy, licensesResp)

		return cpy
	}

	// makeScanResults make a separate instance of ScanResults to avoid mutations changing other tests
	makeScanResults := func() *results.ScanResults {
		scanResults := results.ScanResults{
			ConfigManager: config.Manager{},
		}
		licensesResp = makeLicensesResp()
		for i := range packages {
			vulnPointers := []*models.Vulnerability{}
			for _, vuln := range vulnsResp.Results[i].Vulns {
				vulnPointers = append(vulnPointers, &vuln)
			}
			scanResults.PackageScanResults = append(scanResults.PackageScanResults, imodels.PackageScanResult{
				PackageInfo:     packages[i],
				Vulnerabilities: vulnPointers,
				Licenses:        licensesResp[i],
			})
		}

		return &scanResults
	}

	callAnalysisStates := make(map[string]bool)

	tests := []struct {
		name string
		args args
	}{
		{
			name: "group_vulnerabilities",
			args: args{
				r:           &reporter.VoidReporter{},
				scanResults: makeScanResults(),
				actions: ScannerActions{
					ExperimentalScannerActions: ExperimentalScannerActions{
						ShowAllPackages:       false,
						ScanLicensesAllowlist: nil,
					},
					CallAnalysisStates: callAnalysisStates,
				},
			},
		},
		{
			name: "group_vulnerabilities_with_all_packages_included",
			args: args{
				r:           &reporter.VoidReporter{},
				scanResults: makeScanResults(),
				actions: ScannerActions{
					ExperimentalScannerActions: ExperimentalScannerActions{
						ShowAllPackages:       true,
						ScanLicensesAllowlist: nil,
					},
					CallAnalysisStates: callAnalysisStates,
				},
			},
		}, {
			name: "group_vulnerabilities_with_licenses",
			args: args{
				r:           &reporter.VoidReporter{},
				scanResults: makeScanResults(),
				actions: ScannerActions{
					ExperimentalScannerActions: ExperimentalScannerActions{
						ShowAllPackages:       true,
						ScanLicensesSummary:   true,
						ScanLicensesAllowlist: nil,
					},
					CallAnalysisStates: callAnalysisStates,
				},
			},
		}, {
			name: "group_vulnerabilities_with_license_allowlist",
			args: args{
				r:           &reporter.VoidReporter{},
				scanResults: makeScanResults(),

				actions: ScannerActions{
					ExperimentalScannerActions: ExperimentalScannerActions{
						ShowAllPackages:       false,
						ScanLicensesAllowlist: []string{"MIT", "0BSD"},
					},
					CallAnalysisStates: callAnalysisStates,
				},
			},
		}, {
			name: "group_vulnerabilities_with_license_allowlist_and_license_override",
			args: args{
				r:           &reporter.VoidReporter{},
				scanResults: makeScanResults(),
				actions: ScannerActions{
					ExperimentalScannerActions: ExperimentalScannerActions{
						ShowAllPackages:       false,
						ScanLicensesAllowlist: []string{"MIT", "0BSD"},
					},
					CallAnalysisStates: callAnalysisStates,
				},
				config: config.Manager{
					OverrideConfig: &config.Config{
						PackageOverrides: []config.PackageOverrideEntry{
							{
								Name:      "pkg-3",
								Ecosystem: "npm",
								License: config.License{
									Override: []string{"MIT"},
								},
							},
						},
					},
				},
			},
		}, {
			name: "group_vulnerabilities_with_license_allowlist_and_all_packages",
			args: args{
				r:           &reporter.VoidReporter{},
				scanResults: makeScanResults(),
				actions: ScannerActions{
					ExperimentalScannerActions: ExperimentalScannerActions{
						ShowAllPackages:       true,
						ScanLicensesAllowlist: []string{"MIT", "0BSD"},
					},
					CallAnalysisStates: callAnalysisStates,
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()
			tt.args.scanResults.ConfigManager = tt.args.config
			got := buildVulnerabilityResults(tt.args.r, tt.args.actions, tt.args.scanResults)
			testutility.NewSnapshot().MatchJSON(t, got)
		})
	}
}
