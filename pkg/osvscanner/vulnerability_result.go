package osvscanner

import (
	"slices"
	"sort"
	"strings"

	"github.com/google/osv-scanner/internal/config"
	"github.com/google/osv-scanner/internal/grouper"
	"github.com/google/osv-scanner/internal/output"
	"github.com/google/osv-scanner/internal/sourceanalysis"
	"github.com/google/osv-scanner/internal/spdx"
	"github.com/google/osv-scanner/pkg/models"
	"github.com/google/osv-scanner/pkg/osv"
	"github.com/google/osv-scanner/pkg/reporter"
)

// buildVulnerabilityResults takes the responses from the OSV API and the deps.dev API
// and converts this into a VulnerabilityResults. As part is this, it groups
// vulnerability information by source location.
// TODO: This function is getting long, we should refactor it
func buildVulnerabilityResults(
	r reporter.Reporter,
	packages []scannedPackage,
	vulnsResp *osv.HydratedBatchedResponse,
	licensesResp [][]models.License,
	actions ScannerActions,
	configManager *config.Manager,
) models.VulnerabilityResults {
	results := models.VulnerabilityResults{
		Results: []models.PackageSource{},
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}
	for i, rawPkg := range packages {
		includePackage := actions.ShowAllPackages
		var pkg models.PackageVulns

		if rawPkg.Commit != "" {
			pkg.Package.Commit = rawPkg.Commit
			pkg.Package.Name = rawPkg.Name
		} else if rawPkg.PURL != "" {
			var err error
			pkg.Package, err = models.PURLToPackage(rawPkg.PURL)

			if err != nil {
				r.Errorf("Failed to parse purl: %s, with error: %s", rawPkg.PURL, err)
				continue
			}
		}

		if rawPkg.Version != "" && rawPkg.Ecosystem != "" {
			pkg.Package = models.PackageInfo{
				Name:        rawPkg.Name,
				Version:     rawPkg.Version,
				Ecosystem:   string(rawPkg.Ecosystem),
				ImageOrigin: rawPkg.ImageOrigin,
			}
		}

		pkg.DepGroups = rawPkg.DepGroups

		if len(vulnsResp.Results[i].Vulns) > 0 {
			configToUse := configManager.Get(r, rawPkg.Source.Path)
			if !configToUse.ShouldIgnorePackageVulnerabilities(pkg) {
				includePackage = true
				pkg.Vulnerabilities = vulnsResp.Results[i].Vulns
				pkg.Groups = grouper.Group(grouper.ConvertVulnerabilityToIDAliases(pkg.Vulnerabilities))
				for i, group := range pkg.Groups {
					pkg.Groups[i].MaxSeverity = output.MaxSeverity(group, pkg)
				}
			}
		}

		// For Debian-based ecosystems, mark unimportant vulnerabilities within the package.
		// Debian ecosystems may be listed with a version number, such as "Debian:10".
		if strings.HasPrefix(pkg.Package.Ecosystem, string(models.EcosystemDebian)) {
			setUnimportant(&pkg)
		}

		if actions.ScanLicensesSummary || len(actions.ScanLicensesAllowlist) > 0 {
			configToUse := configManager.Get(r, rawPkg.Source.Path)
			if override, entry := configToUse.ShouldOverridePackageLicense(pkg); override {
				if entry.License.Ignore {
					r.Infof("ignoring license for package %s/%s/%s\n", pkg.Package.Ecosystem, pkg.Package.Name, pkg.Package.Version)
					licensesResp[i] = nil
				} else {
					overrideLicenses := make([]models.License, len(entry.License.Override))
					for j, license := range entry.License.Override {
						overrideLicenses[j] = models.License(license)
					}
					r.Infof("overriding license for package %s/%s/%s with %s\n", pkg.Package.Ecosystem, pkg.Package.Name, pkg.Package.Version, strings.Join(entry.License.Override, ","))
					licensesResp[i] = overrideLicenses
				}
			}
			if len(actions.ScanLicensesAllowlist) > 0 {
				pkg.Licenses = licensesResp[i]
				for _, license := range pkg.Licenses {
					satisfies, err := spdx.Satisfies(license, actions.ScanLicensesAllowlist)

					if err != nil {
						r.Errorf("license %s for package %s/%s/%s is invalid: %s\n", license, pkg.Package.Ecosystem, pkg.Package.Name, pkg.Package.Version, err)
					}

					if !satisfies {
						pkg.LicenseViolations = append(pkg.LicenseViolations, license)
					}
				}
				if len(pkg.LicenseViolations) > 0 {
					includePackage = true
				}
			}
			if actions.ScanLicensesSummary {
				pkg.Licenses = licensesResp[i]
			}
		}
		if includePackage {
			groupedBySource[rawPkg.Source] = append(groupedBySource[rawPkg.Source], pkg)
		}
	}

	for source, packages := range groupedBySource {
		sourceanalysis.Run(r, source, packages, actions.CallAnalysisStates)
		results.Results = append(results.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	sort.Slice(results.Results, func(i, j int) bool {
		if results.Results[i].Source.Path == results.Results[j].Source.Path {
			return results.Results[i].Source.Type < results.Results[j].Source.Type
		}

		return results.Results[i].Source.Path < results.Results[j].Source.Path
	})

	if len(actions.ScanLicensesAllowlist) > 0 || actions.ScanLicensesSummary {
		results.ExperimentalAnalysisConfig.Licenses.Summary = actions.ScanLicensesSummary
		allowlist := make([]models.License, len(actions.ScanLicensesAllowlist))
		for i, l := range actions.ScanLicensesAllowlist {
			allowlist[i] = models.License(l)
		}
		results.ExperimentalAnalysisConfig.Licenses.Allowlist = allowlist
	}

	return results
}

// setUnimportant marks vulnerabilities in a PackageVulns as unimportant
// within their respective groups' experimental analysis.
func setUnimportant(pkg *models.PackageVulns) {
	for _, vuln := range pkg.Vulnerabilities {
		if !isUnimportant(vuln.Affected) {
			continue
		}
		for i, group := range pkg.Groups {
			if slices.Contains(group.IDs, vuln.ID) {
				if group.ExperimentalAnalysis == nil {
					pkg.Groups[i].ExperimentalAnalysis = make(map[string]models.AnalysisInfo)
				}
				// Set unimportant vulns as uncalled
				pkg.Groups[i].ExperimentalAnalysis[vuln.ID] = models.AnalysisInfo{
					Unimportant: true,
					// TODO(gongh@): Currently, call analysis is not supported for Linux distribution vulnerabilities.
					// The `Called` configuration is set to false by default.
					// Update this behavior when call analysis for Linux distributions is implemented.
				}

				break
			}
		}
	}
}

// isUnimportant checks if a Debian vulnerability is tagged with an "unimportant" urgency tag
// Urgency levels are defined here: https://security-team.debian.org/security_tracker.html#severity-levels
func isUnimportant(affectedPackages []models.Affected) bool {
	for _, affected := range affectedPackages {
		if affected.EcosystemSpecific["urgency"] == "unimportant" {
			return true
		}
	}

	return false
}
