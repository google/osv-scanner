package osvscanner

import (
	"slices"
	"sort"
	"strconv"
	"strings"

	"github.com/google/osv-scanner/internal/utility/fileposition"
	"github.com/google/osv-scanner/internal/utility/location"

	"github.com/google/osv-scanner/internal/output"
	"github.com/google/osv-scanner/internal/sourceanalysis"
	"github.com/google/osv-scanner/pkg/config"
	"github.com/google/osv-scanner/pkg/grouper"
	"github.com/google/osv-scanner/pkg/models"
	"github.com/google/osv-scanner/pkg/osv"
	"github.com/google/osv-scanner/pkg/reporter"
)

func exportMetadata(rawPkg scannedPackage) map[models.PackageMetadataType]string {
	metadata := make(map[models.PackageMetadataType]string)

	if len(rawPkg.PackageManager) > 0 && rawPkg.PackageManager != models.Unknown {
		metadata[models.PackageManagerMetadata] = string(rawPkg.PackageManager)
	}
	if rawPkg.IsDirect {
		metadata[models.IsDirectDependencyMetadata] = strconv.FormatBool(rawPkg.IsDirect)
	}
	if rawPkg.Ecosystem.IsDevGroup(rawPkg.DepGroups) {
		metadata[models.IsDevDependencyMetadata] = strconv.FormatBool(true)
	}

	return metadata
}

// buildVulnerablityResults takes the responses from the OSV API and the deps.dev API
// and converts this into a VulnerabilityResults. As part is this, it groups
// vulnerability information by source location.
// TODO: This function is getting long, we should refactor it
func buildVulnerabilityResults(
	r reporter.Reporter,
	packages []scannedPackage,
	artifacts []models.ScannedArtifact,
	vulnsResp *osv.HydratedBatchedResponse,
	licensesResp [][]models.License,
	actions ScannerActions,
	configManager *config.ConfigManager,
) models.VulnerabilityResults {
	results := models.VulnerabilityResults{
		Results:   []models.PackageSource{},
		Artifacts: artifacts,
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}
	for i, rawPkg := range packages {
		if packageHasRangedVersion(rawPkg) {
			continue
		}
		includePackage := actions.ShowAllPackages
		var pkg models.PackageVulns

		if rawPkg.Commit != "" {
			pkg.Package.Commit = rawPkg.Commit
			pkg.Package.Name = rawPkg.Name
		} else if rawPkg.PURL != "" {
			var err error
			pkg.Package, err = models.PURLToPackage(rawPkg.PURL)

			if err != nil {
				r.Errorf("Failed to parse purl: %s, with error: %s", rawPkg.PURL, err)
				continue
			}
		}

		if rawPkg.Ecosystem != "" {
			pkg = models.PackageVulns{
				Package: models.PackageInfo{
					Name:      rawPkg.Name,
					Version:   rawPkg.Version,
					Ecosystem: string(rawPkg.Ecosystem),
				},
				Metadata: exportMetadata(rawPkg),
			}
		}

		pkg.DepGroups = rawPkg.DepGroups

		if len(vulnsResp.Results[i].Vulns) > 0 {
			includePackage = true
			pkg.Vulnerabilities = vulnsResp.Results[i].Vulns
			pkg.Groups = grouper.Group(grouper.ConvertVulnerabilityToIDAliases(pkg.Vulnerabilities))
			for i, group := range pkg.Groups {
				pkg.Groups[i].MaxSeverity = output.MaxSeverity(group, pkg)
			}
		}
		if actions.ScanLicensesSummary || len(actions.ScanLicensesAllowlist) > 0 {
			configToUse := configManager.Get(r, rawPkg.Source.Path)
			if override, entry := configToUse.ShouldOverridePackageVersionLicense(pkg.Package.Name, pkg.Package.Version, pkg.Package.Ecosystem); override {
				overrideLicenses := make([]models.License, len(entry.License.Override))
				for j, license := range entry.License.Override {
					overrideLicenses[j] = models.License(license)
				}
				r.Infof("overriding license for package %s/%s/%s with %s\n", pkg.Package.Ecosystem, pkg.Package.Name, pkg.Package.Version, strings.Join(entry.License.Override, ","))
				licensesResp[i] = overrideLicenses
			}
			if len(actions.ScanLicensesAllowlist) > 0 {
				pkg.Licenses = licensesResp[i]
				for _, license := range pkg.Licenses {
					lowerLicense := strings.ToLower(string(license))
					if !slices.ContainsFunc(actions.ScanLicensesAllowlist, func(l string) bool {
						return strings.ToLower(l) == lowerLicense
					}) {
						pkg.LicenseViolations = append(pkg.LicenseViolations, license)
					}
				}
				if len(pkg.LicenseViolations) > 0 {
					includePackage = true
				}
			}

			if fileposition.IsFilePositionExtractedSuccessfully(rawPkg.BlockLocation) {
				pkg.Locations = make([]models.PackageLocations, 1)
				pkg.Locations[0] = location.NewPackageLocations(rawPkg.BlockLocation, rawPkg.NameLocation, rawPkg.VersionLocation)
			} else {
				pkg.Locations = make([]models.PackageLocations, 0)
			}

			if actions.ScanLicensesSummary {
				pkg.Licenses = licensesResp[i]
			}
		}
		if includePackage {
			groupedBySource[rawPkg.Source] = append(groupedBySource[rawPkg.Source], pkg)
		}
	}

	for source, packages := range groupedBySource {
		sourceanalysis.Run(r, source, packages, actions.CallAnalysisStates)
		results.Results = append(results.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	sort.Slice(results.Results, func(i, j int) bool {
		if results.Results[i].Source.Path == results.Results[j].Source.Path {
			return results.Results[i].Source.Type < results.Results[j].Source.Type
		}

		return results.Results[i].Source.Path < results.Results[j].Source.Path
	})

	if len(actions.ScanLicensesAllowlist) > 0 || actions.ScanLicensesSummary {
		results.ExperimentalAnalysisConfig.Licenses.Summary = actions.ScanLicensesSummary
		allowlist := make([]models.License, len(actions.ScanLicensesAllowlist))
		for i, l := range actions.ScanLicensesAllowlist {
			allowlist[i] = models.License(l)
		}
		results.ExperimentalAnalysisConfig.Licenses.Allowlist = allowlist
	}

	return results
}

// grouped by source location.
func groupBySource(r reporter.Reporter, packages []scannedPackage, artifacts []models.ScannedArtifact) models.VulnerabilityResults {
	output := models.VulnerabilityResults{
		Results:   []models.PackageSource{},
		Artifacts: artifacts,
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}

	for _, p := range packages {
		var pkg models.PackageVulns
		switch {
		case p.Ecosystem != "" && p.Name != "":
			pkg = models.PackageVulns{
				Package: models.PackageInfo{
					Name:      p.Name,
					Version:   p.Version,
					Ecosystem: string(p.Ecosystem),
				},
				Metadata: exportMetadata(p),
			}
		case p.Commit != "":
			pkg.Package.Version = p.Commit
			pkg.Package.Ecosystem = "GIT"
		case p.PURL != "":
			var err error
			pkg.Package, err = models.PURLToPackage(p.PURL)
			if err != nil {
				r.Errorf("Failed to parse purl: %s, with error: %s", p.PURL, err)
				continue
			}
		default:
			r.Warnf("package %v does not have a commit, PURL or ecosystem/name/version identifier\n", p)
			continue
		}

		pkg.Vulnerabilities = nil
		pkg.Groups = nil
		if fileposition.IsFilePositionExtractedSuccessfully(p.BlockLocation) {
			pkg.Locations = make([]models.PackageLocations, 1)
			pkg.Locations[0] = location.NewPackageLocations(p.BlockLocation, p.NameLocation, p.VersionLocation)
		} else {
			pkg.Locations = make([]models.PackageLocations, 0)
		}
		groupedBySource[p.Source] = append(groupedBySource[p.Source], pkg)
	}

	for source, packages := range groupedBySource {
		output.Results = append(output.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	return output
}

func packageHasRangedVersion(scannedPackage scannedPackage) bool {
	return !strings.ContainsAny(scannedPackage.Version, "<>,")
}
