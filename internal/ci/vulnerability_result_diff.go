package ci

import (
	"slices"

	"github.com/google/osv-scanner/pkg/grouper"
	"github.com/google/osv-scanner/pkg/models"
)

// DiffVulnerabilityResults will return any new vulnerabilities that are in `newRes`
// which is not present in `oldRes`, but not the reverse.
//
// Current implementation is O(n^2) on the number of vulns, but can be reduced to linear time
func DiffVulnerabilityResults(oldRes, newRes models.VulnerabilityResults) models.VulnerabilityResults {
	result := models.VulnerabilityResults{}
	for _, ps := range newRes.Results {
		sourceIdx := slices.IndexFunc(oldRes.Results, func(elem models.PackageSource) bool { return elem.Source == ps.Source })
		if sourceIdx == -1 {
			// Newly introduced source, so all results for this source are going to be new, add everything for this source
			result.Results = append(result.Results, ps)
			continue
		}
		// Otherwise the old source used to exist, so we need to find the difference in the packages
		result.Results = append(result.Results, models.PackageSource{
			Source: ps.Source,
		})
		resultPS := &result.Results[len(result.Results)-1]
		for _, pv := range ps.Packages {
			pkgs := oldRes.Results[sourceIdx].Packages
			pkgIdx := slices.IndexFunc(pkgs, func(elem models.PackageVulns) bool { return elem.Package == pv.Package })
			if pkgIdx == -1 {
				// Newly introduced package, so all results for this package are going to be new, add everything for this package
				resultPS.Packages = append(resultPS.Packages, pv)
				continue
			}
			// Otherwise the old package used to exist, so we need to find the difference in the vulnerabilities
			// Only copy over packages as vulns and groups might change
			resultPS.Packages = append(resultPS.Packages, models.PackageVulns{
				Package: pv.Package,
			})
			resultPV := &resultPS.Packages[len(resultPS.Packages)-1]
			for _, v := range pv.Vulnerabilities {
				vulns := pkgs[pkgIdx].Vulnerabilities
				vulnIdx := slices.IndexFunc(vulns, func(elem models.Vulnerability) bool { return elem.ID == v.ID })
				if vulnIdx == -1 {
					// Vulnerability is new, add it to the results
					resultPV.Vulnerabilities = append(resultPV.Vulnerabilities, v)
					continue
				}
			}
			if len(resultPV.Vulnerabilities) == 0 {
				// No vulns, so we can remove the PackageVulns entry entirely, and skip grouping
				resultPS.Packages = resultPS.Packages[:len(resultPS.Packages)-1]
				continue
			}
			// Rebuild the groups lost in the previous step
			groups := grouper.Group(grouper.ConvertVulnerabilityToIDAliases(resultPV.Vulnerabilities))
			resultPV.Groups = groups
		}
		if len(resultPS.Packages) == 0 {
			// No packages, so we can remove the PackageSource entry entirely
			result.Results = result.Results[:len(result.Results)-1]
			continue
		}
	}

	return result
}

// DiffVulnerabilityResultsByOccurrences will return the occurrence of each vulnerability that are in `newRes`
// which is not present in `oldRes`, but not the reverse. This calculates the difference by vulnerability ID,
// while ignoring the source of the vulnerability.
//
// This prevents us reporting "new" vulnerabilities in a PR when a previously vulnerable file is being moved.
func DiffVulnerabilityResultsByOccurrences(oldRes, newRes models.VulnerabilityResults) map[string]int {
	oldResFlat := oldRes.Flatten()
	newResFlat := newRes.Flatten()

	oldResMap := map[string]int{}
	newResMap := map[string]int{}

	for _, vf := range oldResFlat {
		oldResMap[vf.Vulnerability.ID] += 1
	}

	for _, vf := range newResFlat {
		newResMap[vf.Vulnerability.ID] += 1
	}

	for k, oldVulnCount := range oldResMap {
		// If the new result has less vulnerabilities than the old result remove the entry from the new result.
		// `map`'s default value is 0 when empty, and delete also works fine when the entry is empty
		if newResMap[k] <= oldVulnCount {
			delete(newResMap, k)
		}
	}

	return newResMap
}
